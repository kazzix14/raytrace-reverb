layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(set = 0, binding = 0) buffer ImageBuffer {
    vec4 pixels[];
} image;

layout(set = 0, binding = 1) buffer ConstantsBuffer {
    uvec2 image_size;
} constants;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Sphere {
    float radius;
    vec3  position;
    vec3 color;
    float reflection_ratio;
    // boolean
    int emission;
};

struct Plane {
    vec3 position;
    vec3 normal;
    vec3 color;
    float reflection_ratio;
};

struct Intersection {
    int   hit;
    int hit_emission;
    vec3  hitPoint;
    vec3  normal;
    vec3  color;
    float distance;
    vec3  rayDir;
    float intensity;
};

const vec3  LDR = vec3(0.577);
const float EPS = 0.0001;
const int   MAX_REF = 128;
const float dump_ratio = 0.000000;
const float rand_ratio = 1.0;
const float noise_angle = 0.1;
const int EXEC_COUNT = 128;

Sphere sphere[3];
Plane plane[6];

float rand(vec2 co) {
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 rotate(vec3 p, float angle, vec3 axis) {
    vec3 a = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float r = 1.0 - c;
    mat3 m = mat3(
        a.x * a.x * r + c,
        a.y * a.x * r + a.z * s,
        a.z * a.x * r - a.y * s,
        a.x * a.y * r - a.z * s,
        a.y * a.y * r + c,
        a.z * a.y * r + a.x * s,
        a.x * a.z * r + a.y * s,
        a.y * a.z * r - a.x * s,
        a.z * a.z * r + c
    );
    return m * p;
}

void initialize_intersection(inout Intersection intersection) {
    intersection.hit      = 0;
    intersection.hitPoint = vec3(0.0);
    intersection.normal   = vec3(0.0);
    intersection.color    = vec3(0.0);
    intersection.intensity = 1.0;
    intersection.distance = 1.0e+30;
    intersection.rayDir   = vec3(0.0);
    intersection.hit_emission = 0;
}

void intersect_sphere(Ray ray, Sphere sphere, inout Intersection intersection){
    vec3  a = ray.origin - sphere.position;
    float b = dot(a, ray.direction);
    float c = dot(a, a) - (sphere.radius * sphere.radius);
    float d = b * b - c;
    float t = -b - sqrt(d);
    if(d > 0.0 && t > EPS && t < intersection.distance){
        intersection.hitPoint = ray.origin + ray.direction * t;
        intersection.normal = normalize(intersection.hitPoint - sphere.position);
        d = clamp(dot(LDR, intersection.normal), 0.1, 1.0);
        intersection.color = sphere.color * d;
        intersection.distance = t;
        intersection.hit++;
        intersection.rayDir = ray.direction;

        intersection.intensity *= max(1.0 - intersection.distance * dump_ratio, 0.0);

        if(sphere.emission == 1) {
            intersection.hit--;
            intersection.hit_emission += 1;
        }
        else
        {
            intersection.intensity *= sphere.reflection_ratio;
        }
    }
}

void intersect_plane(Ray ray, Plane plane, inout Intersection intersection){
    float d = -dot(plane.position, plane.normal);
    float v = dot(ray.direction, plane.normal);
    float t = -(dot(ray.origin, plane.normal) + d) / v;
    if(t > EPS && t < intersection.distance){
        intersection.hitPoint = ray.origin + ray.direction * t;
        intersection.normal = plane.normal;
        float d = clamp(dot(LDR, intersection.normal), 0.1, 1.0);
        float m = mod(intersection.hitPoint.x, 2.0);
        float n = mod(intersection.hitPoint.z, 2.0);
        float f = 1.0 - min(abs(intersection.hitPoint.z), 25.0) * 0.04;
        intersection.color = plane.color * d * f;
        intersection.distance = t;
        intersection.hit++;
        intersection.rayDir = ray.direction;
        intersection.intensity *= max(1.0 - intersection.distance * dump_ratio, 0.0);
        intersection.intensity *= plane.reflection_ratio;
    }
}

void intersectExec(Ray ray, inout Intersection intersection){
    intersect_sphere(ray, sphere[0], intersection);
    intersect_sphere(ray, sphere[1], intersection);
    intersect_sphere(ray, sphere[2], intersection);
    intersect_plane(ray, plane[0], intersection);
    intersect_plane(ray, plane[1], intersection);
    intersect_plane(ray, plane[2], intersection);
    intersect_plane(ray, plane[3], intersection);
    intersect_plane(ray, plane[4], intersection);
    intersect_plane(ray, plane[5], intersection);
}


void compute() {
    float intensity = 0.0;
    for (int count = 0; count < EXEC_COUNT; count++)
    {
        // -1.0 ..= 1.0
        vec2 p = vec2(gl_GlobalInvocationID) / constants.image_size * vec2(2.0) - vec2(1.0);
        p.y = -p.y;

        Ray ray;
        ray.origin = vec3(0.0, 2.0, 4.0);
        ray.direction = normalize(vec3(p.x, p.y, -0.5));

        // sphere init
        sphere[0].radius = 0.5;
        sphere[0].position = vec3(0.0, -0.5, sin(1.0));
        sphere[0].color = vec3(1.0, 0.0, 0.0);
        sphere[0].reflection_ratio = 1.0;
        sphere[0].emission = 0;

        sphere[1].radius = 1.0;
        sphere[1].position = vec3(2.0, 0.0, cos(1.0 * 0.666));
        sphere[1].color = vec3(0.0, 1.0, 0.0);
        sphere[1].reflection_ratio = 1.0;
        sphere[1].emission = 0;

        sphere[2].radius = 1.5;
        sphere[2].position = vec3(-2.0, 0.5, cos(1.0 * 0.333));
        sphere[2].color = vec3(0.0, 0.0, 1.0);
        sphere[2].reflection_ratio = 1.0;
        sphere[2].emission = 1;

        // plane init
        plane[0].position = vec3(0.0, -5.0, 0.0);
        plane[0].normal = vec3(0.0, 1.0, 0.0);
        plane[0].color = vec3(0.0, 1.0, 0.0);
        plane[0].reflection_ratio = 1.0;

        plane[1].position = vec3(0.0, 5.0, 0.0);
        plane[1].normal = vec3(0.0, -1.0, 0.0);
        plane[1].color = vec3(1.0, 0.0, 1.0);
        plane[1].reflection_ratio = 1.0;

        plane[2].position = vec3(-5.0, 0.0, 0.0);
        plane[2].normal = vec3(1.0, 0.0, 0.0);
        plane[2].color = vec3(1.0, 0.0, 0.0);
        plane[2].reflection_ratio = 1.0;

        plane[3].position = vec3(5.0, 0.0, 0.0);
        plane[3].normal = vec3(-1.0, 0.0, 0.0);
        plane[3].color = vec3(0.0, 1.0, 1.0);
        plane[3].reflection_ratio = 1.0;

        plane[4].position = vec3(0.0, 0.0, -5.0);
        plane[4].normal = vec3(0.0, 0.0, 1.0);
        plane[4].color = vec3(0.0, 0.0, 1.0);
        plane[4].reflection_ratio = 1.0;

        plane[5].position = vec3(0.0, 0.0, 5.0);
        plane[5].normal = vec3(0.0, 0.0, -1.0);
        plane[5].color = vec3(1.0, 1.0, 0.0);
        plane[5].reflection_ratio = 1.0;

        // intersection init
        Intersection its;
        initialize_intersection(its);

        // hit check
        vec3 destColor = vec3(ray.direction.y);
        vec3 tempColor = vec3(0.0);
        Ray q;
        intersectExec(ray, its);
        if(its.hit > 0){
            destColor = its.color;
            tempColor *= its.color;
            for(int j = 1; j < MAX_REF; j++){
                q.origin = its.hitPoint + its.normal * EPS;

                q.direction = reflect(its.rayDir, its.normal);
                q.direction += 2.0 * rand_ratio * normalize(vec3(rand(its.hitPoint.xy * vec2(100.0) + float(count)), rand(its.hitPoint.xy * vec2(200.0) + float(count)), rand(its.hitPoint.xy * vec2(300.0) + float(count)))) - rand_ratio;

                //vec3 noised_normal = rotate(its.normal, noise_angle , normalize(vec3(2.0*rand(its.hitPoint.xy * vec2(100.0) + float(count)) - 1.0, 2.0*rand(its.hitPoint.xy * vec2(200.0) + float(count)) - 1.0, 2.0*rand(its.hitPoint.xy * vec2(300.0) + float(count)) - 1.0)));
                //noised_normal = normalize(noised_normal);
                //vec3 mixed_normal = normalize((rand_ratio) * noised_normal + (1.0 - rand_ratio) * its.normal);
                //vec3 reflected = normalize(reflect(its.rayDir, mixed_normal));
                //q.direction = reflected;

                intersectExec(q, its);
                if(its.hit > j){
                    destColor += tempColor * its.color;
                    tempColor *= its.color;
                }
            }
        }

        if (its.hit_emission == 0) {
            its.intensity = 0;
        }
        intensity += its.intensity;
    }

    intensity = intensity / float(EXEC_COUNT);

    uint index =
        gl_GlobalInvocationID.y * constants.image_size.x +
        gl_GlobalInvocationID.x;                

    //image.pixels[index] = vec4(destColor, 1.0);
    image.pixels[index] = vec4(vec3(intensity), 1.0);
}